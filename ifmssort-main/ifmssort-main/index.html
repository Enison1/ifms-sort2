<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>HOME</title>
    <link rel="stylesheet" href="style.css" />
  </head>

  <body>
    <header>
      <nav>
        <a class="logo" href="index.html">IFMS SORT</a>
        <div class="mobile-menu">
          <div class="line1"></div>
          <div class="line2"></div>
          <div class="line3"></div>
        </div>
        <ul class="nav-list">
          <li><a href="index.html">HOME</a></li>
          <li><a href="Bubble.html">BUBBLE</a></li>
          <li><a href="Comb.html">COMB</a></li>
          <li><a href="Count.html">COUNT</a></li>
          <li><a href="Insertion.html">INSERTION</a></li>
          <li><a href="Merge.html">MERGE</a></li>
          <li><a href="Quick.html">QUICK</a></li>
          <li><a href="Radix.html">RADIX</a></li>
          <li><a href="Selection.html">SELECTION</a></li>
          <li><a href="Shell.html">SHELL</a></li>
          <li><a href="Tim.html">TIM</a></li>
          <li><a href="Geral.html">GERAL</a></li>
        </ul>
      </nav>
    </header>

    <div class="texto">
      <h1>O que é um algoritmo de ordenação?</h1>
      <p>
        Os algoritmos de ordenação são um conjunto de instruções que recebem um
        array ou lista como entrada e organizam os itens em uma ordem
        específica.
      </p>
      <p>
        As ordenações mais comumente realizadas são a numérica ou a alfabética
        (também chamada de lexicográfica) e podem ser em ordem crescente (A-Z,
        0-9) ou decrescente (Z-A, 9-0).
      </p>
      <h2>Por que algoritmos de ordenação são importantes?</h2>
      <p>
        Os algoritmos de ordenação são importantes em Ciência da Computação
        porque a ordenação pode, muitas vezes, reduzir a complexidade de um
        problema. Esses algoritmos têm aplicações diretas em algoritmos de
        busca, algoritmos de banco de dados, métodos de divisão e conquista,
        algoritmos de estrutura de dados e muito mais.
      </p>
      <h2>Vantagens e desvantagens dos algoritmos</h2>
      <p>
        Ao usar algoritmos diferentes, algumas perguntas devem ser feitas. Qual
        o tamanho da coleção que está sendo ordenada? Quanta memória está
        disponível para uso? A coleção precisa crescer?
      </p>
      <p>
        As respostas a essas perguntas podem determinar qual algoritmo
        funcionará melhor para a situação. Alguns algoritmos como a ordenação
        por intercalação (<em>merge sort</em>, em inglês) podem precisar de
        muito espaço para serem executados, enquanto a ordenação por inserção
        nem sempre é a mais rápida, mas não requer muitos recursos para isso.
      </p>
      <p>
        Você deve determinar quais são os requisitos do sistema e suas
        limitações antes de decidir qual algoritmo usar.
      </p>
      <h2>Algoritmos de ordenação comuns</h2>
      <p>Alguns dos algoritmos de ordenação mais comuns são:</p>
      <div class="lado">
        <ul>
          <li>Bubble Sort</li>
          <li>Comb Sort</li>
          <li>Count Sort</li>
          <li>Insertion Sort</li>
          <li>Merge Sort</li>
          <li>Quick Sort</li>
          <li>Radix Sort</li>
          <li>Selection Sort</li>
          <li>Shell Sort</li>
          <li>Tim Sort</li>
        </ul>
      </div>
      <p>
        Antes de detalharmos cada um deles, contudo, vamos aprender um pouco
        mais sobre como são classificados os algoritmos de ordenação.
      </p>
      <h2>Classificação de um algoritmo de ordenação</h2>
      <p>
        Os algoritmos de ordenação podem ser categorizados com base nos
        seguintes parâmetros:
      </p>
      <div class="lado">
        <ol>
          <li>
            <strong
              >Baseado no número de trocas ou inversões necessários:</strong
            >
            Este é o número de vezes que o algoritmo troca os elementos para
            ordenar uma entrada. A ordenação por seleção requer o número mínimo
            de trocas.
          </li>
          <li>
            <strong>Baseado no número de comparações:</strong> Este é o número
            de vezes que o algoritmo compara elementos para ordenar uma entrada.
            Usando os exemplos de algoritmos de ordenação listados acima
            requerem, pelo menos, <code>O(nlogn)</code> comparações no melhor
            caso e <code>O(n^2)</code> comparações no pior caso para a maioria
            das saídas.
          </li>
          <li>
            <strong>Baseado no uso ou não de recursão:</strong> Alguns
            algoritmos, tal como <code>Quick Sort</code> (ordenação rápida), usa
            técnicas recursivas para ordenar uma entrada. Outros algoritmos de
            ordenação, como &nbsp;<code>Selection Sort</code> (ordenação por
            seleção) ou &nbsp;<code>Insertion Sort</code> (ordenação por
            inserção), usam técnicas não recursivas. Por fim, alguns algoritmos
            de ordenação, como &nbsp;<code>Merge Sort</code> (ordenação por
            intercalação), usam tanto técnicas recursivas como não recursivas
            para ordenar uma entrada.
          </li>
          <li>
            <strong>Baseado na estabilidade:</strong> Algoritmos de ordenação
            são considerados &nbsp;<code>estáveis</code> se o algoritmo mantiver
            a ordem relativa dos elementos com chaves iguais. Em outras
            palavras, dois elementos equivalentes permanecem, após a ordenação,
            na mesma ordem em que estavam antes da ordenação.<br />Imagine, por
            exemplo, que tenhamos um array de entrada
            <code>[1, 2, 3, 2, 4]</code>. Para ajudar na diferenciação entre os
            valores que são iguais – neste caso, os <code>2</code> – usaremos
            <code>2a</code> e <code>2b</code>, tornando o array &nbsp;<code
              >[1, 2a, 3, 2b, 4]</code
            >.<br />Algoritmos de ordenação estáveis manterão a ordem de
            <code>2a</code> e <code>2b</code>. Ou seja, teremos o algoritmo
            ordenado <code>[1, 2a, 2b, 3, 4]</code>. Já os instáveis, por sua
            vez, não mantêm a ordem dos valores iguais, resultando em
            <code>[1, 2b, 2a, 3, 4]</code>. <code>Insertion sort</code> ,
            &nbsp;<code>Merge Sort</code> &nbsp;e &nbsp;<code>Bubble Sort</code>
            são estáveis, enquanto <code>Heap Sort</code> &nbsp;e
            <code>Quick Sort</code> não são.
          </li>
          <li>
            <strong>Baseado na necessidade de espaço adicional:</strong> Alguns
            algoritmos podem ordenar uma lista sem criar outra inteiramente
            nova. Chamamos um algoritmo assim de algoritmo de ordenação
            &nbsp;<code>in loco</code> e ele requer um espaço adicional
            <code>O(1)</code> constante para a ordenação. Quando os algoritmos
            não são <code>in loco</code>, &nbsp;uma outra lista é criada durante
            a ordenação.<br /><code>Insertion sort</code> &nbsp;e &nbsp;<code
              >Quick sort</code
            >
            realizam a ordenação <code>in loco</code>, já que os elementos são
            movidos em torno de um ponto fixo e não utilizam um array à parte
            durante o processo de ordenação. <br />No <code>Merge sort</code>,
            por outro lado, o tamanho da entrada deve ser alocado de antemão
            para armazenar a saída durante o processo de ordenação. Isso exige
            um espaço adicional na memória para o processo de ordenação.
          </li>
        </ol>
      </div>
    </div>
    <footer>
      <p class="texto">&copy; Enison e Antonio</p>
    </footer>

    <script src="mobile-navbar.js"></script>
  </body>
</html>
